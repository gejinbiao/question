# B树、B-树、B+树、B*树介绍

#B树
B-树就是B树（可能有部分人会习惯上把B-树读为B减树，其实并不存在B减树，只是读法上的不同而已），B就是balanced，平衡的意思。B-树就是指的B树，特此说明一下。
先介绍一下二叉搜索树。

1. 顾名思义，二叉搜索树，即指最多拥有两个叉，这里的叉即为所有非叶子结点的儿子（Lift和Right）；
1. 所有的结点存储一个关键字；
1. 非叶子结点的左指针指向小于其关键字的结点，右指针指向对于其关键字的结点，结构如下图：

![UKM6NF.png](https://s1.ax1x.com/2020/07/10/UKM6NF.png)

二叉搜索树的搜索，从根结点开始，如果查询的关键字与结点关键字相等，则该结点为查询的结点，如果查询关键字比结点关键字小，则进入左子树，反之则进入右子树；如果左子树为空或者右子树为空，则返回查找不到响应的关键字；
如果二叉搜索树的所有叶子结点的左右子树的树木保持一个平衡即左右子树个数大致相等的话，其搜索则更接近与二分查找；但是它相比连续内存空的二分查找的优点是：改变二叉搜索树的结构（添加或者删除）不需要大段的移动数据，甚至通常都是常数开销；
如下图：
红色字体代表插入数据，搜索二叉树在插入结点时，只要根据插入数据的大小查找出他应该插入的位置即可，然而当在一个有序数组插入一个数据的时候，需要查询出他的位置，然后将其添加，后面的数据索引加一，这样的一个完整操作，相比下来二叉树的优点很明显了。
![UKMH4e.png](https://s1.ax1x.com/2020/07/10/UKMH4e.png)

但是，当一个二叉树经历多次删除操作后，他就可能变换结构，如下图：

![UKQF3j.png](https://s1.ax1x.com/2020/07/10/UKQF3j.png)

右边也是一个搜索二叉树，只不过不在平衡了，他的搜索功能也变成了线性的，同样的关键字可能导致不同的树结构索引，所以，在使用搜索二叉树时，还要烤炉尽可能让B树保持左图的结构，避免和右图类似，这也有事所谓的平衡问题了。

实际使用的二叉搜索树都是在原二叉搜索树的基础上加上平衡算法，即平衡二叉树；如何保持B树节点分布均匀的平衡算法就是平衡二叉树的关键所在，平衡算法是一种在二叉搜索树的插入和删除结点时的一种策略。即：在插入或删除的同时保持二叉搜索树的平衡。

B树（B-树），是一种多路搜索树（并非二叉的）：

1. 定义任意非叶子节点最多可以有M个儿子节点；且M>2；
1. 则根节点的儿子数为：[2，M]；
1. 除根节点为的非叶子节点的儿子书为[M/2，M]；
1. 每个结点存放至少M/2 - 1 （去上整）且至多M -1 个关键字；（至少为2）；
1. 非叶子结点的关键字个数 = 指向子节点的指针书 -1；
1. 非叶子节点的关键字：K[1],K[2],K[3],…,K[M-1;且K[i] < K[i +1];
1. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
1. 所有叶子结点位于同一层；

如(M = 3)

![UKQZD0.png](https://s1.ax1x.com/2020/07/10/UKQZD0.png)

B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果

命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为

空，或已经是叶子结点；

B-树的特性：

1. 关键字集合分布在整颗树中；
1. 任何一个关键字出现且只出现在一个结点中；
1. 搜索有可能在非叶子结点结束；
1. 其搜索性能等价于在关键字全集内做一次二分查找；
1. 自动层次控制；

# B+树

B+树是B-树的变体，也是一种多路搜索树：

1.其定义基本与B-树同，除了：

2.非叶子结点的子树指针与关键字个数相同；

3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；

5.为所有叶子结点增加一个链指针；

6.所有关键字都在叶子结点出现；

如：（M=3）

![UKQl8J.png](https://s1.ax1x.com/2020/07/10/UKQl8J.png)

B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在

非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

B+树的特性：

1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；

2.不可能在非叶子结点命中；

3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；

# B*树

B树是B+树一种变形，它是在B+树的基础上，将索引层以指针连接起来，使搜索取值更加快捷。
如下图（M = 3）

![UKQUUO.png](https://s1.ax1x.com/2020/07/10/UKQUUO.png)

但是B树又在B+树的基础上产生了一系列的变化，如下：

1. B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3代替B+树的1/2）；
1. B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
1. *树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；


所以B*树相对于B+树，空间利用率上有所提高，查询速率也有所提高。

总结：

二叉搜索树：二叉树，每个结点只存储一个关键字且值大于左子树，小于右子树。

B（B-）树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树

中出现，且只出现一次，非叶子结点可以命中；

B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点
中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；

B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率
从1/2提高到2/3；
